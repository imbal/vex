#!/usr/bin/env python3
"""

vex is a command line program for saving changes to a project, switching
between different versions, and sharing those changes.

vex supports bash completion: run `complete -o nospace -C vex vex`

"""
import os
import sys
import os.path
import traceback
import subprocess
import tempfile

from contextlib import contextmanager

sys.path.append(os.path.split(os.path.abspath(__file__))[0])


from vexlib.cli import Command, print_result
from vexlib.project import Project
from vexlib.errors import VexBug, VexNoProject, VexNoHistory, VexUnclean, VexError, VexArgument

DEFAULT_CONFIG_DIR = ".vex"
DEFAULT_INCLUDE = ["*"] 
DEFAULT_IGNORE =  [".*", DEFAULT_CONFIG_DIR, ".DS_Store", "*~", "*.swp", "__*__"]

fake = False

@contextmanager
def watcher():
    p = subprocess.run('fswatch --version', stdout=subprocess.DEVNULL, shell=True)
    if p.returncode: raise VexBug('fswatch is not installed')

    p = subprocess.Popen('fswatch .', shell=True, stdout=subprocess.PIPE)
    def watch_files():
        line = None
        while True:
            try:
                line = p.stdout.readline()
                if not line: break
                yield line.decode('utf-8').rstrip()
            except KeyboardInterrupt:
                break
    try:
        yield watch_files
    finally:
        p.terminate()

def get_project():
    working_dir = os.getcwd()
    while True:
        config_dir = os.path.join(working_dir,  DEFAULT_CONFIG_DIR)
        if os.path.exists(config_dir):
            break
        new_working_dir = os.path.split(working_dir)[0]
        if new_working_dir == working_dir:
            return None
        working_dir = new_working_dir
    return Project(config_dir, working_dir, fake=fake)

def open_project(allow_empty=False):
    p = get_project()
    if not p:
        raise VexNoProject('no vex project found in {}'.format(os.getcwd()))
    if not allow_empty and p.history_isempty():
        raise VexNoHistory('Vex project exists, but `vex init` has not been run (or has been undone)')
    elif not p.clean_state():
        raise VexUnclean('Another change is already in progress. Try `vex debug:status`')
    return p
    

# CLI bits. Should handle environs, cwd, etc
vex_cmd = Command('vex', 'a database for files', long=__doc__)

@vex_cmd.on_complete()
def Complete(prefix, field, argtype):
    if argtype == 'path':
        if prefix:
            return ["{} ".format(p) for p in os.listdir() if p.startswith(prefix)]
        else:
            return ["{} ".format(p) for p in os.listdir() if not p.startswith('.')]
    elif argtype in ('bool', 'boolean'):
        out = ('true ','false ')
        if prefix:
            return [p for p in out if p.startswith(prefix)]
        else:
            return out

    elif argtype == 'branch':
        p = open_project()
        if p:
            out = p.list_branches()
            if prefix:
                return ["{} ".format(name) for name, uuid in out if name.startwith(prefix)]
            else:
                return ["{} ".format(name) for name, uuid in out if name]

    return ()


@vex_cmd.on_call()
def Call(mode, path, args, callback):
    """ calling vex foo:bar args, calls this function with 'call', ['foo', 'bar'], args, and
        a callback that is the right function to call
    """
    global fake # so sue me
    if mode == 'fake':
        fake = True
    try:
        result = callback()
        if result is not None:
            print_result(result)
        return 0

    except Exception as e:
        if mode =="debug":
            raise
        result= "".join(traceback.format_exception(*sys.exc_info()))
        message = str(e)
        vex_error = isinstance(e, VexError)

    if path:
        print("{}: error: {}".format(':'.join(path), message))
    else:
        print("vex: error: {}".format(message))

    if not vex_error:
        print("\nWorse still, it's an error vex doesn't recognize yet. A python traceback follows:\n")
        print(result)

    p = get_project()

    if p and p.exists() and not p.clean_state():
        with p.lock('rollback') as p:
            p.rollback_new_action()

            if not p.clean_state():
                print('This is bad: The project history is corrupt, try `vex debug:status` for more information')
            else:
                print('Good news: The changes that were attempted have been undone')
    return -1


vex_init = vex_cmd.subcommand('init',short="create a new vex project")
@vex_init.run('''
    --working:path    # Working directory, where files are edited/changed
    --config:path     # Normally /working_dir/.vex if not given 
    --prefix:path     # Subdirectory to check out of the repository, normally the working directory name
    --include:str... # files to include whe using vex add, can be passed multiple times 
    --ignore:str...  # files to ignore when using vex add, can be passed multiple times
    [directory]  #
''')
def Init(directory, working, config, prefix, include, ignore):
    """
        Create a new vex project in a given directory. 

        - If no directory given, it is assumed to be the current directory.
        - Inside that directory, a `.vex` directory is created to store the project history.
        - An initial empty commit is added.
        - The subtree checkout defaults to `/directory_name`.
        
        i.e a `vex init` in `/a/b` creates a `/a/b/.vex` directory, an empty commit, and checks
        out `/b` in the repo, into `/a/b` on the filesystem.`

        If you make a mistake, `vex undo` will undo the initial commit, but not remove
        the `.vex` directory. 

        `init` takes multiple `--include=<file>` and `--ignore=<file>` arguments, 
        defaulting to `--include='*' --ignore='.vex' --ignore='.*'`

        `--include`, `--ignore`, can be passed multiple times, and work the 
        same as `vex include 'pattern'` and `vex ignore 'pattern'`

    """

    working_dir = working or directory or os.getcwd()
    config_dir = config or os.path.join(working_dir,  DEFAULT_CONFIG_DIR)
    prefix = prefix or os.path.split(working_dir)[1] or ''
    prefix = os.path.join('/', prefix)

    include = include or DEFAULT_INCLUDE
    ignore = ignore or DEFAULT_IGNORE

    p = Project(config_dir, working_dir, fake)

    if p.exists() and not p.clean_state():
        yield ('This vex project is unwell. Try `vex debug:status`')
    elif p.exists():
        if not p.history_isempty():
            raise VexError("A vex project already exists here")
        else:
            yield ('A empty project was round, re-creating project in "{}"...'.format(os.path.relpath(config_dir)))
            with p.lock('init') as p:
                p.init(prefix, include, ignore)
    else:
        p.makedirs()
        p.makelock()
        with p.lock('init') as p:
            yield ('Creating vex project in "{}"...'.format(working_dir))
            p.init(prefix, include, ignore)


vex_undo = vex_cmd.subcommand('undo', short="undo the last command")
@vex_undo.run()
def Undo():
    """
        `vex undo` will return the project to how it was before the last command changed 
        things. running `vex undo:list` will show the list of commands that can be undone.

        for example:

        - `vex diff` / `vex status` / `vex log` and some other commands do not do anything
        and so cannot be undone.

        - calling `vex undo` after `vex commit` will not change the working copy, but will 
        remove the commit from the list of changes to the project

        - calling `vex undo` after calling `vex switch` to change which directory inside the
        repo to work on, will change the directory back. Edits to files are not undone.

        - calling `vex undo` after creating a branch with `vex new` will switch back
        to the old branch, but save the existing local changes incase `vex redo` is called.

        `vex undo:list` shows the list of commands that have been performed,
        and the order they will be undone in.

        similarly `vex redo:list` shows the actions that can be redone.
    """

    p = open_project()

    with p.lock('undo') as p:
        action = p.undo()
    if action:
        yield 'undid {}'.format(action.command)

vex_undo_list = vex_undo.subcommand('list', short="list the commands that canbe undone")
@vex_undo_list.run()
def UndoList():
    """
        `vex undo` will return the project to how it was before the last command changed 
        things. running `vex undo:list` will show the list of commands that can be undone.

        `vex undo:list` shows the list of commands that have been performed,
        and the order they will be undone in.

        similarly `vex redo:list` shows the actions that can be redone.
    """

    p = open_project()

    count = 0
    for entry,redos in p.list_undos():
        count -= 1
        alternative = ""
        if len(redos) == 1:
            alternative = "(then ran but undid: {})".format(redos[0].command)
        elif len(redos) > 0:
            alternative = "(then ran but undid: {}, and {} )".format(",".join(r.command for r in redos[:-1]), redos[-1].command)

        yield "{}: {}, ran {}\t{}".format(count, entry.time, entry.command,alternative)
        yield ""

vex_redo = vex_cmd.subcommand('redo', "redo last undone command")
@vex_redo.run('''
    --choice:int # Which command to redo. `--choice=0` means the last action uandone.     
''')
def Redo(choice):
    """
        `vex redo` will redo the last action undone. `vex redo --list` will show the
        list of commands to choose from.

        `vex redo` is not the same as re-running the command, as `vex redo` will
        repeat the original changes made, without consulting the files in the working copy,
        or restoring the files if the command is something like `vex open`. 

        for example, redoing a `vex commit` will not commit the current versions of the files in the project
        
        redoing a `vex new <branch_name>` will reopen a branch, restoring the working copy
        with any local changes before `vex undo` was called.
        
        similarly, calling undo and redo on a `vex switch` operation, will just change which
        directory is checked out, saving and restoring local changes to files.

        if you do a different action after undo, you can still undo and redo.

        `vex redo:list` shows the actions that can be redone and `vex redo --choice=<n>` picks one.

        The order of the list changes when you pick a different item to redo. 
    """
    p = open_project(allow_empty=True)

    with p.lock('redo') as p:
        choices = p.list_redos()

        if choices:
            choice = choice or 0
            action = p.redo(choice)
            if action:
                yield 'redid {}'.format(action.command)
        else:
            yield ('Nothing to redo')


vex_redo_list = vex_redo.subcommand('list', "list the commands that can be redone")
@vex_redo_list.run()
def RedoList():
    """
        `vex redo` will redo the last action undone. `vex redo:list` will show the
        list of commands to choose from.
    """
    p = open_project(allow_empty=True)

    with p.lock('redo') as p:
        choices = p.list_redos()

        if choices:
            for n, choice in enumerate(choices):
                yield "{}: {}, {}".format(n, choice.time, choice.command)
        else:
            yield ('Nothing to redo')


vex_status = vex_cmd.subcommand('status', short="list the files being tracked by vex")
@vex_status.run('''
    --all?      # Show all files inside the repo, even ones outside working copy
    --missing?  # Show untracked files
''')
def Status(all, missing):
    """
        `vex status` shows the state of each visible file, `vex status --all` shows the status 
        of every file in the current session/branch.
    """
    p = open_project()
    cwd = os.getcwd()
    with p.lock('status') as p:
        files = p.status()
        for reponame in sorted(files, key=lambda p:p.split(':')):
            entry = files[reponame]
            path = os.path.relpath(reponame, p.prefix())
            if entry.working is None:
                if all:
                    yield "hidden:{:9}\t{} ".format(entry.state, path)
            elif reponame.startswith('/.vex/') or reponame == '/.vex':
                if all:
                    yield "{}:{:8}\t{}".format('setting', entry.state, path)
            else:
                yield "{:16}\t{}{}".format(entry.state, path, ('*' if entry.stash else '') )
        yield ""
        if all or missing:
            for f in p.untracked(os.getcwd()):
                path = os.path.relpath(f)
                yield "{:16}\t{}".format('untracked', path)


vex_log = vex_cmd.subcommand('log', aliases=['changelog'], short="list changes to project")
@vex_log.run()
def Log():
    """
        `vex changelog` or `vex log` shows the list of commits inside a branch, using 
        the current branch if none given.
    """
    
    p = open_project()
    for entry in p.log():
        yield (entry)
        yield ""


vex_cmd_diff = vex_cmd.group('diff')
vex_diff = vex_cmd_diff.subcommand('diff', short="show the current changes to the project as a diff")
vex_diff_file = vex_diff.subcommand('file', short='show changed files since last commit')
argspec = '''
    [file:path...] # difference between two files
'''
@vex_diff.run(argspec)
@vex_diff_file.run(argspec)
def Diff(file):
    """
        `vex diff` shows the changes waiting to be committed for the given files
    """
    p = open_project()
    with p.lock('diff') as p:
        cwd = os.getcwd()
        files = file if file else None # comes in as []
        for name, diff in  p.active_diff_files(files).items():
            yield diff

vex_cmd_files = vex_cmd.group('files')

vex_add = vex_cmd_files.subcommand('add','add files to the project')
@vex_add.run('''
    --include:str... # files to include whe using vex add, can be passed multiple times 
    --ignore:str...  # files to ignore when using vex add, can be passed multiple times
    [file:path...]     # filename or directory to add
''')
def Add(include, ignore, file):
    """
        `vex add` will add all files given to the project, and recurse through
        subdirectories too.

        it uses the settings in `vex ignore` and `vex include`

    """
    cwd = os.getcwd()
    if not file:
        files = [cwd]
    else:
        files = file
    missing = [f for f in file if not os.path.exists(f)]
    if missing:
        raise VexArgument('cannot find {}'.format(",".join(missing)))
    p = open_project()
    include = include if include else None
    ignore = ignore if ignore else None
    with p.lock('add') as p:
        for f in p.add(files, include=include, ignore=ignore):
            f = os.path.relpath(f)
            yield "add: {}".format(f)

vex_forget = vex_cmd_files.subcommand('forget','remove files from the project, without deleting them')
@vex_forget.run('''
        [file:path...] # Files to remove from next commit
''')
def Forget(file):
    """
        `vex forget` will instruct vex to stop tracking a file, and it will not appear
        inside the next commit.

        it does not delete the file from the working copy.
    """
    if not file:
        return

    file = [f for f in file if os.path.exists(f)]
    p = open_project()
    with p.lock('forget') as p:
        for f in p.forget(file).values():
            f = os.path.relpath(f)
            yield "forget: {}".format(f)

vex_remove = vex_cmd_files.subcommand('remove','remove files from the project, deleting them')
@vex_remove.run('''
        [file:path...] # Files to remove from working copy
''')
def Remove(file):
    """
        `vex remove` will instruct vex to stop tracking a file, and it will not appear
        inside the next commit.

        it will delete the file from the working copy.
    """
    if not file:
        return

    file= [f for f in file if os.path.exists(f)]
    p = open_project()
    with p.lock('remove') as p:
        for f in p.remove(file).values():
            f = os.path.relpath(f)
            yield "remove: {}".format(f)

vex_restore = vex_cmd_files.subcommand('restore','restore files from the project, overwriting modifications')
@vex_restore.run('''
        [file:path...] # Files to restore to working copy
''')
def Restore(file):
    """
        `vex restore` will change a file back to how it was 
    """
    if not file:
        return

    p = open_project()
    with p.lock('restore') as p:
        for f in p.restore(file).values():
            f = os.path.relpath(f)
            yield "restore: {}".format(f)
vex_missing = vex_cmd_files.subcommand('missing','files in current directory but not in project', aliases=['untracked'])
@vex_missing.run('')
def Missing():
    """
        `vex missing` shows missing files
    """
    p = open_project()
    for f in p.untracked(os.getcwd()):
            f = os.path.relpath(f)
            yield "missing: {}".format(f)
vex_cmd_commit = vex_cmd.group("commit")

vex_prepare = vex_cmd_commit.subcommand('prepare', short="save current working copy to prepare for commit", aliases=['save'])
@vex_prepare.run('''
        --add?          # Run `vex add` before commiting
        --watch?         # Unsupported
        [file:path...] # Files to add to the commt 
''')
def Prepare(file,watch, add):
    """
        `vex prepare` is like `vex commit`, except that the next commit will inherit all of the 
        changes made.

        preparory commits are not applied to branches.
    """
    p = open_project()
    yield ('Preparing')
    with p.lock('prepare') as p:
        if add:
            for f in p.add([os.getcwd()]):
                f = os.path.relpath(f)
                yield "add: {}".format(f)

        cwd = os.getcwd()
        files = file if file else None
        if watch:
            active = p.active()
            prefix = p.prefix()
            with watcher() as files:
                for file in files():
                    if p.check_file(file):
                        repo = p.full_to_repo_path(prefix, file)
                        if repo in active.files:
                            p.prepare([file])
                            yield os.path.relpath(file)
        else:
            p.prepare(files)

vex_commit = vex_cmd_commit.subcommand('commit', short="save the working copy and add an entry to the project changes")
@vex_commit.run('''
    --add?          # Run `vex add` before commiting
    [file:path...]       # Commit only a few changed files
''')
def Commit(add, file):
    """
        `vex commit` saves the current state of the project.

    """
    p = open_project()
    with p.lock('commit') as p:
        if add:
            for f in p.add([os.getcwd()]):
                f = os.path.relpath(f)
                yield "add: {}".format(f)

        cwd = os.getcwd()
        files = file if file else None

        changes = p.commit_active(files)

        if changes:
            for name, entries in changes.items():
                entries = [entry.text for entry in entries]
                name = os.path.relpath(name, p.prefix())
                yield "commit: {}, {}".format(', '.join(entries), name)

        else:
            yield 'commit: Nothing to commit'

vex_commit_prepared = vex_commit.subcommand('prepared', short="commit prepared files")
@vex_commit_prepared.run()
def CommitPrepared():
    """
        `vex commit:prepared` transforms earlier `vex prepare` into a commit

    """
    p = open_project()
    with p.lock('commit:prepared') as p:
        changes = p.commit_prepared()
        if changes:
            for name, entries in changes.items():
                entries = [entry.text for entry in entries]
                name = os.path.relpath(name, p.prefix())
                yield "commit: {}, {}".format(', '.join(entries), name)
        else:
            yield 'commit: Nothing to commit'


vex_amend = vex_commit.subcommand('amend', short="replace the last commit with the current changes in the project")
@vex_amend.run('''
        [file:path...] # files to change
''')
def Amend(file):
    """
        `vex amend` allows you to re-commit, indicating that the last commit
        was incomplete.

        `vex amend` is like `vex prepare`, except that it operates on the last commit, 
        instead of preparing for the next.

    """
    p = open_project()
    yield ('Amending')
    with p.lock('amend') as p:
        cwd = os.getcwd()
        files = file if file else None
        if p.amend(files):
            yield 'Committed'
        else:
            yield 'Nothing to commit'
        # check that session() and branch()

vex_message = vex_cmd_commit.subcommand('message', short="edit commit message")
vex_message_edit = vex_message.subcommand('edit', short='edit commit message')
@vex_message.run('--editor')
@vex_message_edit.run('--editor')
def EditMessage(editor):
    p = open_project()
    with p.lock('editor') as p:
        if not editor and p.state.exists('editor'):
            editor = p.state.get('editor')
        if not editor:
            editor = os.environ.get('EDITOR')
        if not editor:
            editor = os.environ.get('VISUAL')
        file = p.settings.filename('message')
        if not editor:
            path = os.path.relpath(file)
            raise VexArgument('with what editor?, you can open ./{} directly too'.format(path))
        p.state.set('editor', editor)
    os.execvp(editor, [editor, file])


vex_message_get = vex_message.subcommand('get', 'get commit message')
@vex_message_get.run('')
def GetMessage():
    p = open_project()
    if p.settings.exists('message'):
        yield p.settings.get('message')

vex_message_set = vex_message.subcommand('set', 'set commit message')
@vex_message_set.run('message')
def SetMessage(message):
    p = open_project()
    with p.lock('message:set') as p:
        p.settings.set('message', message)
        yield "set"


vex_cmd_branch = vex_cmd.group('branch')

vex_branch = vex_cmd_branch.subcommand('branch', short="open/create branch")
@vex_branch.run('[name:branch]')
def Branch(name):
    """

    """
    p = open_project()
    with p.lock('open') as p:
        if name:
            p.open_branch(name, create=True)
        active = p.active()
        branch = p.branches.get(active.branch)
        yield branch.name

vex_branch_list = vex_branch.subcommand('list', short="list branches")
vex_branches = vex_cmd_branch.subcommand('branches', short="list branches")
@vex_branch_list.run()
@vex_branches.run()
def Branches():
    p = open_project()
    with p.lock('branches') as p:
        branches = p.list_branches()
        active = p.active()
        for (name, branch) in branches:
            if branch.uuid == active.branch:
                if name:
                    yield "{} *".format(name)
                else:
                    yield "{} *".format(branch.uuid)
            elif name:
                yield name
            else:
                yield branch.uuid

vex_branch_get = vex_branch.subcommand('get', short="get branch info", aliases=["show", "info"])
@vex_branch_get.run('[name:branch]')
def BranchInfo(name):
    """

    """
    p = open_project()
    with p.lock('branch') as p:
        if not name:
            active = p.active()
            branch = p.branches.get(active.branch)
        else:
            b = p.names.get(name)
            if b:
                branch = p.branches.get(b)
            else:
                raise VexArgument("{} isn't a branch".format(name)) 
        # session is ahead (in prepared? in commits?)
        # session has detached ...?
        # 
        yield branch.name

vex_open = vex_branch.subcommand('open', short="open or create a branch")
@vex_open.run('name:branch')
def OpenBranch(name):
    """

    """
    p = open_project()
    with p.lock('open') as p:
        p.open_branch(name, create=False)

vex_new = vex_branch.subcommand('new', short="create a new branch")
@vex_new.run('name:branch')
def NewBranch(name):
    """

    """
    p = open_project()
    with p.lock('new') as p:
        if p.names.exists(name):
            raise VexArgument('{} exists'.format(name))
        p.new_branch(name)

vex_saveas = vex_branch.subcommand('saveas', short="save session as a new branch, leaving old one alone")
@vex_saveas.run('name:branch')
def SaveAsBranch(name):
    """

    """
    p = open_project()
    with p.lock('saveas') as p:
        if p.names.get(name):
            raise VexArgument('{} exists'.format(name))
        p.save_as(name)

vex_rename = vex_branch.subcommand('rename', short="rename current branch")
@vex_rename.run('name:branch')
def RenameBranch(name):
    """

    """
    p = open_project()
    with p.lock('rename') as p:
        if p.names.get(name):
            raise VexArgument('{} exists'.format(name))
        p.rename_branch(name)

vex_swap = vex_branch.subcommand('swap', short="swap name with another branch")
@vex_swap.run('name:branch')
def SwapBranch(name):
    """

    """
    p = open_project()
    with p.lock('swap') as p:
        if not p.names.get(name):
            raise VexArgument("{} doesn't exist".format(name))
        p.swap_branch(name)


vex_diff_branch = vex_diff.subcommand('branch')
vex_branch_diff = vex_branch.subcommand('diff')
argspec= ('''
        [branch:branch] # name of branch to check, defaults to current branch
''')
@vex_diff_branch.run(argspec)
@vex_branch_diff.run(argspec)
def DiffBranch(branch):
    """
        `vex diff:branch` shows the changes bewtween working copy and a branch
    """
    p = open_project()
    with p.lock('diff') as p:
        if not branch:
            branch = p.active().branch
        else:
            branch = p.get_branch_uuid(branch)

        branch = p.get_branch(branch)
        commit = branch.head

        for name, diff in  p.active_diff_commit(commit).items():
            yield diff

vex_switch = vex_cmd_files.subcommand('switch', short="change which directory (inside the project) is worked on")
@vex_switch.run('[prefix]')
def Switch(prefix):
    """

    """
    p = open_project()
    if prefix:
        with p.lock('switch') as p:
            prefix = os.path.join(p.prefix(), prefix)
            p.switch(prefix)
    else:
        yield p.prefix()

vex_session = vex_cmd_branch.subcommand('session',short="describe the active session for the current branch")
vex_sessions = vex_cmd_branch.subcommand('sessions',short="show all sessions for current branch")

@vex_sessions.run()
def Sessions():
    p = open_project()
    with p.lock('sessions') as p:
        sessions = p.list_sessions()
        active = p.active()
        for s in sessions:
            if s.uuid == active.uuid:
                yield "{} *".format(s.uuid)
            else:
                yield s.uuid

# XXX: vex session:open session:new session:attach session:detach session:remove


vex_ignore = vex_cmd_files.subcommand('ignore', short="add ignored files")
vex_ignore_add = vex_ignore.subcommand('add', 'add ignored files')
@vex_ignore.run('[file...]')
@vex_ignore_add.run('[file...]')
def AddIgnore(file):
    p = open_project()
    if file:
        with p.lock('ignore:add') as p:
            old = p.settings.get('ignore')
            old.extend(file)
            p.settings.set('ignore', old)
    else:
        for entry in p.settings.get('ignore'):
            yield entry


vex_include = vex_cmd_files.subcommand('include', short="add include files")
vex_include_add = vex_include.subcommand('add', 'add include files')
@vex_include.run('[file...]')
@vex_include_add.run('[file...]')
def AddInclude(file):
    p = open_project()
    if file:
        with p.lock('include:add') as p:
            old = p.settings.get('include')
            old.extend(file)
            p.settings.set('include', old)
    else:
        for entry in p.settings.get('include'):
            yield entry


props_cmd = vex_cmd_files.subcommand('fileprops', short="get/set properties on files", aliases=['props', 'properties', 'property'])
props_list_cmd = props_cmd.subcommand('get', short="list properties")
@props_cmd.run('file')
@props_list_cmd.run('file')
def ListProps(file):
    p = open_project()
    with p.lock('fileprops:list') as p:
        for key,value in p.get_fileprops(file).items():
            file = os.path.relpath(file)
            yield "{}:{}:{}".format(file, key,value)

props_set_cmd = props_cmd.subcommand('set', short='set property')
@props_set_cmd.run('file name value:scalar')
def SetProp(file, name, value):
    p = open_project()
    with p.lock('fileprops:list') as p:
        p.set_fileprop(filename, name, value)


vex_cmd_apply = vex_cmd.group('apply')
vex_apply = vex_cmd_apply.subcommand('apply', 'apply changes from other branch to current session')
@vex_apply.run('branch')
def Apply(branch):
    p = open_project()
    with p.lock('apply') as p:
        if not p.names.exists(branch):
            raise VexArgument('{} doesn\'t exist'.format(branch))
        p.apply_changes_from_branch(branch)

vex_append = vex_cmd_apply.subcommand('append', 'append changes from other branch to current session')
@vex_append.run('branch')
def Append(branch):
    p = open_project()
    with p.lock('append') as p:
        if not p.names.exists(branch):
            raise VexArgument('{} doesn\'t exist'.format(branch))
        p.append_changes_from_branch(branch)

vex_replay = vex_cmd_apply.subcommand('replay', 'replay changes from other branch to current session')
@vex_replay.run('branch')
def Replay(branch):
    p = open_project()
    with p.lock('replay') as p:
        if not p.names.exists(branch):
            raise VexArgument('{} doesn\'t exist'.format(branch))
        p.replay_changes_from_branch(branch)

# Rollback, Revert, Squash, Update,

vex_cmd_debug = vex_cmd.group('debug')
vex_debug = vex_cmd_debug.subcommand('debug', 'internal: run a command without capturing exceptions, or repairing errors')
@vex_debug.run()
def Debug():
    """
    `vex debug commit` calls `vex commit`, but will always print a full traceback
    and never attempt to recover from incomplete changes.

    use with care.
    """
    yield ('Use vex debug <cmd> to run <cmd>, or use `vex debug:status`')

vex_stash = vex_debug.subcommand('stash', short="internal: save progress without making a commit or checkpoint to undo")
@vex_stash.run('--watch')
def Stash(watch):
    p = open_project()
    with p.lock('stash') as p:
        if not watch:
            p.stash()
        else:
            with watcher() as files:
                for file in files():
                    p.stash(files=[file])
                    yield os.path.relpath(file)

debug_status = vex_debug.subcommand('status')
@debug_status.run()
def DebugStatus():
    p = open_project(check=False)
    with p.lock('debug:status') as p:
        yield ("Clean history", p.clean_state())
        head = p.active()
        out = []
        if head:

            out.append("head: {}".format(head.uuid))
            out.append("at {}, started at {}".format(head.prepare, head.commit))

            branch = p.branches.get(head.branch)
            out.append("commiting to branch {}".format(branch.uuid))

            commit = p.get_commit(head.prepare)
            out.append("last commit: {}".format(commit.__class__.__name__))
        else:
            if p.history_isempty():
                out.append("you undid the creation. try vex redo")
            else:
                out.append("no active head, but history, weird")
        out.append("")
        return "\n".join(out)


debug_restart = vex_debug.subcommand('restart')
@debug_restart.run()
def DebugRestart():
    p = get_project()
    with p.lock('debug:restart') as p:
        if p.clean_state():
            yield ('There is no change in progress to restart')
            return
        yield ('Restarting current action...')
        p.restart_new_action()
        if p.clean_state():
            yield ('Project has recovered')
        else:
            yield ('Oh dear')

debug_rollback = vex_debug.subcommand('rollback')
@debug_rollback.run()
def DebugRollback():
    p = get_project()
    with p.lock('debug:rollback') as p:
        if p.clean_state():
            yield ('There is no change in progress to rollback')
            return
        yield ('Rolling back current action...')
        p.rollback_new_action()
        if p.clean_state():
            yield ('Project has recovered')
        else:
            yield ('Oh dear')
vex_cmd_git = vex_cmd.group('git')
git_cmd = vex_cmd_git.subcommand('git', short="interact with a git repository")

git_init_cmd = git_cmd.subcommand('init', short='create a new git project')
@git_init_cmd.run('--name --email directory')
def GitInit(name, email, directory):
    pass
    # call Init with new settings


git_set_cmd = git_cmd.subcommand('set', short='set git options')
@git_set_cmd.run('--number? --string? --boolean? name value')
def GitSet(number, string, boolean, name, value):
    pass

git_get_cmd = git_cmd.subcommand('get', short='get git options')
@git_get_cmd.run('name')
def GitGet(name):
    pass


debug_test = vex_debug.subcommand('test', short="self test")
@debug_test.run()
def DebugTest():
    def shell(args):
        print('shell:', args)
        p= subprocess.run(args, stdout=subprocess.PIPE, shell=True)
        if p.returncode:
            sys.stdout.write(p.stdout)
            raise Exception('error')
        return p.stdout

    class Vex:
        def __init__(self, path, command=()):
            self.path = path
            self.command = command

        def __getattr__(self, name):
            return self.__class__(self.path, self.command+(name,))

        def __call__(self, *args, **kwargs):
            cmd = []
            cmd.append(self.path)
            if self.command:
                cmd.append(":".join(self.command))
            for name, value in kwargs.items():
                if isinstance(value, (list, tuple)):
                    for v in value:
                        cmd.append("--{}={}".format(name, v))
                else:
                    cmd.append("--{}={}".format(name, value))
            for value in args:
                cmd.append(value)

            p=  subprocess.run(cmd, stdout=subprocess.PIPE)
            if p.returncode:
                sys.stdout.buffer.write(p.stdout)
                raise Exception('Error')
            print("vex {}:".format(" ".join(cmd[1:])))
            for line in p.stdout.splitlines():
                print(">  ", line.decode('utf-8'))

    vex = Vex(os.path.abspath(__file__))

    with tempfile.TemporaryDirectory() as dir:
        print("Using:", dir)
        os.chdir(dir)
        shell('mkdir repo')
        dir = os.path.join(dir, 'repo')
        os.chdir(dir)

        vex.init()

        shell('date >> date')
        shell('mkdir -p dir1 dir2 dir3/dir3.1 dir3/dir3.2')
        shell('echo yes >> dir1/a')
        shell('echo yes >> dir1/b')
        shell('echo yes >> dir1/c')

        vex.add()
        vex.commit()

        vex.undo()
        vex.prepare()
        vex.commit.prepared()

        vex.undo()
        vex.undo()
        vex.redo(choice=1)
        vex.log()
        shell('date >> date')
        vex.switch('dir1')
        shell('rm a')
        shell('mkdir a')
        vex.switch('/repo')
        vex.undo()
        vex.redo()
        vex.commit()
        shell('rmdir dir2')
        shell('date >> dir2')
        vex.commit()
        vex.undo()
        vex.branch.saveas('other')
        vex.branch('latest')
        vex.undo()
        vex.commit()
        vex.branch('latest')
        vex.status()

    

vex_cmd.main(__name__, adverbs=('debug','fake'))
